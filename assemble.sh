#!/usr/bin/env bash
# vim: filetype=bash tabstop=8

# DO NOT EDIT THIS FILE WITH AN EDITOR THAT WILL AUTOMATICALLY CONVERT TABS TO SPACES.

# If this script ever fails with messages about running out of disk space, it
# is most likely because the size of the packages we install have grown over
# time. You should first confirm that the error is coming from `apt` or `dpkg`
# and isn't user error (e.g. you didn't accidentally copy a huge file into
# the src/post-bootstrap directory).
CFG_DISKSIZE_MB=7095


if [[ "$UID" -ne 0 ]]; then
    echo "This script must be run using sudo."
    exit
fi

set -o errexit
set -o xtrace

if [[ "${1}" == "clean" ]]; then
    which seq
    which rm

    for i in $(seq 0 100); do
        RUNCOUNT="${i}"
        WORKDIR="SYSTEM.${RUNCOUNT}"
        if [[ -e "./${WORKDIR}" ]]; then
            rm -rvf "./${WORKDIR}"
        fi
    done
fi

if [[ "${1}" == "build" ]]; then
    which rsync
    which chroot
    which cp
    which echo
    which cat
    which sed
    which tr
    which mkdir
    which dd
    which parted
    which readlink
    which rm
    which seq
    which losetup
    which debootstrap
    which mount
    which umount
    which pkill
    which mkfs.msdos
    which mkfs.ext3

    for i in $(seq 0 100); do
        RUNCOUNT="${i}"
        WORKDIR="SYSTEM.${RUNCOUNT}"
        if [[ ! -e "${WORKDIR}" ]]; then
            break
        fi
    done
    WORKPATH=$(readlink -f "${WORKDIR}")
    SCRATCHPATH="${WORKPATH}/scratch"
    TMPDISKFILE="${SCRATCHPATH}/DISK"
    DISKFILE="${WORKPATH}/DISK"
    TARGETPATH="${WORKPATH}/target"
    EFIPATH="${WORKPATH}/efi"

    function cleanup_after_build_or_error () {
        set +o errexit
        if [[ -d "${TARGETPATH}" ]]; then
            pids=$(sudo lsof -Fp "${TARGETPATH}" | sed -e '/^p/!d' -e 's/^p//')
            for pid in $pids; do
                kill $pid
                sleep 1
            done
        fi
        [[ "${OUTSIDE_PROCPATH}" ]] && umount "${OUTSIDE_PROCPATH}"
        [[ "${OUTSIDE_DEVPTSPATH}" != "" ]] && umount "${OUTSIDE_DEVPTSPATH}"
        umount "${TARGETPATH}"
        umount "${EFIPATH}"
        [[ -f "${TMPDISKFILE}" ]] && cp "${TMPDISKFILE}" "${DISKFILE}"
        losetup --detach "${LOOP_DEVICE}"
        umount "${SCRATCHPATH}"
    }
    trap "{ cleanup_after_build_or_error; }" EXIT

    mkdir "${WORKPATH}"
    mkdir "${SCRATCHPATH}"
    mount -t tmpfs none "${SCRATCHPATH}"
    mkdir "${TARGETPATH}"
    mkdir "${EFIPATH}"

    # Create a new file to use as a disk. This specifies /dev/zero as the input
    # file. However, that is really just a placeholder to satisfy dd. Since we
    # use the seek= option alongwith count=0, the disk isn't actually zeroed.
    # If you want the disk to be zeroed, change this to use:
    #     seek=0 count="${CFG_DISKSIZE_MB}"
    dd if=/dev/zero of="${TMPDISKFILE}" bs=1M count=0 seek="${CFG_DISKSIZE_MB}"

    if [[ ! -f "${TMPDISKFILE}" ]]; then
        # Super paranoid check to ensure we created the disk file.
        echo "Cannot find disk file: ${TMPDISKFILE}"
        exit
    fi

    # Create two partitions. The first is a UEFI System Partition (ESP). The
    # second is where we will install our linux system.
    parted --script "${TMPDISKFILE}" -- mklabel gpt
    parted --script "${TMPDISKFILE}" -- mkpart primary fat32 0 512MiB
    parted --script "${TMPDISKFILE}" -- mkpart primary ext3 512MiB -1MiB
    parted --script "${TMPDISKFILE}" -- set 1 boot on
    parted --script "${TMPDISKFILE}" -- set 1 esp on
    parted --script "${TMPDISKFILE}" -- print

    # Attach the new disk file to a loopback device. The --partscan option
    # causes each partition to be detected and attached to a new loopback
    # device with a "pN" suffix, where "N" is the 1-based partition number.
    LOOP_DEVICE=$(losetup --partscan --find --show "${TMPDISKFILE}")
    if [[ ! -b "${LOOP_DEVICE}" ]]; then
        echo "The loopback device doesn't appear to be a block device: ${LOOP_DEVICE}"
        exit
    fi

    # Format the partitions that we just created.
    mkfs.msdos -F 32 -n ESP "${LOOP_DEVICE}p1"
    mkfs.ext3 "${LOOP_DEVICE}p2"

    # Now we have formatted partitions, let's mount them and start putting
    # files on them.
    mount "${LOOP_DEVICE}p1" "${EFIPATH}"
    mount "${LOOP_DEVICE}p2" "${TARGETPATH}"

    cp -R src/ESP_CONTENTS/* "${EFIPATH}"

    # Warm up the apt cache with packages downloaded by previous runs.
    mkdir -p "${TARGETPATH}/var/cache/apt/archives"
    rsync --verbose --archive src/DEBCACHE/ "${TARGETPATH}/var/cache/apt/archives/"

    DEBOOTSTRAP_PKGLIST=$(cat PACKAGES | sed -e '/^\s*$/d' -e '/^#/d' | tr '\n' ',')
    APT_PKGLIST=$(cat PACKAGES | sed -e '/^\s*$/d' -e '/^#/d' | tr '\n' ' ')
    debootstrap --arch=amd64 --components=main,contrib,non-free --include=makedev,locales,procps,debconf-utils --no-check-gpg --keep-debootstrap-dir stretch "${TARGETPATH}"

    # Copy any packages downloaded by debootstrap back into our shared cache.
    function cache_downloaded_packages () {
        rsync --verbose --archive --filter "include **/*.deb" --filter "exclude *" "${TARGETPATH}/var/cache/apt/archives/" src/DEBCACHE/
    }
    cache_downloaded_packages


    function ensure_directory_exists () {
        if [[ "$1" != "" ]]; then
            dpath=$(dirname "$1")
            mkdir -p "$dpath"
        fi
    }


    # We're going to use chroot to run apt-get inside the target filesystem.
    # The post-install scripts of some packages will require the proc and device
    # filesystems.
    OUTSIDE_PROCPATH="${TARGETPATH}/proc"
    mount -t proc proc "${OUTSIDE_PROCPATH}"

    # Create a naive set of device files inside the chroot. We have to do this
    # before we bind the host /dev/pts to the /dev/pts path inside the chroot.
    chroot "${TARGETPATH}" /sbin/MAKEDEV

    OUTSIDE_DEVPTSPATH="${TARGETPATH}/dev/pts"
    mount --bind /dev/pts "${OUTSIDE_DEVPTSPATH}"


    cache_downloaded_packages

    # Pre-configure packages that require user interaction.
    chroot "${TARGETPATH}" debconf-set-selections < src/debconf-selections

    # Create a script inside the target directory so that it can be run from within a chroot
    INSIDE_SCRIPTPATH="/tmp/setup-inside-chroot.sh"
    OUTSIDE_SCRIPTPATH="${TARGETPATH}${INSIDE_SCRIPTPATH}"
    ensure_directory_exists "${OUTSIDE_SCRIPTPATH}"
    cat > "${OUTSIDE_SCRIPTPATH}" <<-EOF
        mkdir /var/lib/lightdm/data
        chown lightdm:lightdm /var/lib/lightdm/data

        mkdir /var/log/journal
        chgrp systemd-journal /var/log/journal
        chmod g+rwx /var/log/journal

	groupadd --system autologin
	groupadd --system nopasswdlogin
	useradd --user-group --groups autologin,nopasswdlogin,netdev,sudo cctv
	echo cctv:cctv | chpasswd
        chsh --shell /bin/bash cctv


        export DEBIAN_PRIORITY=critical
        export DEBIAN_FRONTEND=noninteractive
        apt-get update
        RUNLEVEL=1 apt-get -o Dpkg::Options::="--force-confdef" -o Dpkg::Options::="--force-confnew" --assume-yes --show-progress install ${APT_PKGLIST}
EOF
    chmod u+x "${OUTSIDE_SCRIPTPATH}"
    chroot "${TARGETPATH}" "${INSIDE_SCRIPTPATH}"

    cache_downloaded_packages
    chroot "${TARGETPATH}" apt-get clean

    # Copy our config files into the chroot
    rsync --verbose --recursive --links --times src/post-bootstrap/ "${TARGETPATH}/"
    chroot "${TARGETPATH}" locale-gen
    chroot "${TARGETPATH}" chown -R cctv:cctv "/home/cctv"
    chroot "${TARGETPATH}" bash /tmp/rtl8723bs/build.sh

    export TARGETPATH
    export EFIPATH
    bash copy_kernel_files_to_efi.sh

fi # End of [[ "${1}" == "build" ]]

