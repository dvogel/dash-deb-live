#!/usr/bin/env bash
# vim: filetype=bash tabstop=8

# DO NOT EDIT THIS FILE WITH AN EDITOR THAT WILL AUTOMATICALLY CONVERT TABS TO SPACES.

# If this script ever fails with messages about running out of disk space, it
# is most likely because the size of the packages we install have grown over
# time. You should first confirm that the error is coming from `apt` or `dpkg`
# and isn't user error (e.g. you didn't accidentally copy a huge file into
# the src/post-bootstrap directory).
CFG_DISKSIZE_MB=4000

# TODO: Deal with this error about /dev/pts:
# E: Can not write log (Is /dev/pts mounted?) - posix_openpt (2: No such file or directory)

# TODO: Deal with this error about /proc:
# Starting SMP IRQ Balancer: irqbalancestart-stop-daemon: nothing in /proc -
# not mounted?  failed!

# TODO: Still prompted to select keyboard layout during apt-get, on keyboard-configuration
#
#perl: warning: Setting locale failed.
#perl: warning: Please check that your locale settings:
#        LANGUAGE = "",
#        LC_ALL = (unset),
#        LANG = "en_US.utf8"
#    are supported and installed on your system.
#perl: warning: Falling back to the standard locale ("C").
#locale: Cannot set LC_CTYPE to default locale: No such file or directory
#locale: Cannot set LC_MESSAGES to default locale: No such file or directory
#locale: Cannot set LC_ALL to default locale: No such file or directory
#Extracting templates from packages: 100%
#Preconfiguring packages ...
#locale: Cannot set LC_CTYPE to default locale: No such file or directory
#locale: Cannot set LC_MESSAGES to default locale: No such file or directory
#locale: Cannot set LC_ALL to default locale: No such file or directory
#locale: Cannot set LC_CTYPE to default locale: No such file or directory
#locale: Cannot set LC_MESSAGES to default locale: No such file or directory
#locale: Cannot set LC_ALL to default locale: No such file or directory
#/usr/bin/locale: Cannot set LC_CTYPE to default locale: No such file or directory
#/usr/bin/locale: Cannot set LC_MESSAGES to default locale: No such file or directory
#/usr/bin/locale: Cannot set LC_ALL to default locale: No such file or directory
#E: Can not write log (Is /dev/pts mounted?) - posix_openpt (2: No such file or directory)
#Fetched 376 MB in 10min 26s (601 kB/s)
#Selecting previously unselected package libgpm2:amd64.
#(Reading database ... 9051 files and directories currently installed.)
#Preparing to unpack .../libgpm2_1.20.4-6.1+b2_amd64.deb ...
#Progress: [  0%]



if [[ "$UID" -ne 0 ]]; then
    echo "This script must be run using sudo."
    exit
fi

set -o errexit
set -o xtrace

if [[ "${1}" == "clean" ]]; then
    which seq
    which rm

    for i in $(seq 0 100); do
        RUNCOUNT="${i}"
        WORKDIR="SYSTEM.${RUNCOUNT}"
        if [[ -e "./${WORKDIR}" ]]; then
            rm -rvf "./${WORKDIR}"
        fi
    done
fi

if [[ "${1}" == "build" ]]; then
    which rsync
    which chroot
    which cp
    which echo
    which cat
    which sed
    which tr
    which mkdir
    which dd
    which parted
    which readlink
    which rm
    which seq
    which losetup
    which debootstrap
    which mount
    which umount
    which mkfs.msdos
    which mkfs.ext3

    for i in $(seq 0 100); do
        RUNCOUNT="${i}"
        WORKDIR="SYSTEM.${RUNCOUNT}"
        if [[ ! -e "${WORKDIR}" ]]; then
            break
        fi
    done
    WORKPATH=$(readlink -f "${WORKDIR}")
    DISKFILE="${WORKPATH}/DISK"
    TARGETPATH="${WORKPATH}/target"
    EFIPATH="${WORKPATH}/efi"

    function cleanup_after_build_or_error () {
        set +o errexit
        umount "${EFIPATH}"
        umount "${TARGETPATH}"
        [[ "${OUTSIDE_PROCPATH}" ]] && umount "${OUTSIDE_PROCPATH}"
        [[ "${OUTSIDE_DEVPTSPATH}" != "" ]] && umount "${OUTSIDE_DEVPTSPATH}"
        losetup --detach "${LOOP_DEVICE}"
    }
    trap "{ cleanup_after_build_or_error; }" EXIT

    mkdir "${WORKPATH}"
    mkdir "${TARGETPATH}"
    mkdir "${EFIPATH}"

    # Create a new file to use as a disk. This specifies /dev/zero as the input
    # file. However, that is really just a placeholder to satisfy dd. Since we
    # use the seek= option alongwith count=0, the disk isn't actually zeroed.
    # If you want the disk to be zeroed, change this to use:
    #     seek=0 count="${CFG_DISKSIZE_MB}"
    dd if=/dev/zero of="${DISKFILE}" bs=1M count=0 seek="${CFG_DISKSIZE_MB}"

    if [[ ! -f "${DISKFILE}" ]]; then
        # Super paranoid check to ensure we created the disk file.
        echo "Cannot find disk file: ${DISKFILE}"
        exit
    fi

    # Create two partitions. The first is a UEFI System Partition (ESP). The
    # second is where we will install our linux system.
    parted --script "${DISKFILE}" -- mklabel gpt
    parted --script "${DISKFILE}" -- mkpart primary fat32 0 256MiB
    parted --script "${DISKFILE}" -- mkpart primary ext3 257MiB -1MiB
    parted --script "${DISKFILE}" -- set 1 boot on
    parted --script "${DISKFILE}" -- set 1 esp on
    parted --script "${DISKFILE}" -- print

    # Attach the new disk file to a loopback device. The --partscan option
    # causes each partition to be detected and attached to a new loopback
    # device with a "pN" suffix, where "N" is the 1-based partition number.
    LOOP_DEVICE=$(losetup --partscan --find --show "${DISKFILE}")
    if [[ ! -b "${LOOP_DEVICE}" ]]; then
        echo "The loopback device doesn't appear to be a block device: ${LOOP_DEVICE}"
        exit
    fi

    # Format the partitions that we just created.
    mkfs.msdos -F 32 -n ESP "${LOOP_DEVICE}p1"
    mkfs.ext3 "${LOOP_DEVICE}p2"

    # Now we have formatted partitions, let's mount them and start putting
    # files on them.
    mount "${LOOP_DEVICE}p1" "${EFIPATH}"
    mount "${LOOP_DEVICE}p2" "${TARGETPATH}"

    cp -R src/ESP_CONTENTS/* "${EFIPATH}"

    # Warm up the apt cache with packages downloaded by previous runs.
    mkdir -p "${TARGETPATH}/var/cache/apt/archives"
    rsync --verbose --archive src/DEBCACHE/ "${TARGETPATH}/var/cache/apt/archives/"

    DEBOOTSTRAP_PKGLIST=$(cat PACKAGES | sed -e '/^\s*$/d' -e '/^#/d' | tr '\n' ',')
    APT_PKGLIST=$(cat PACKAGES | sed -e '/^\s*$/d' -e '/^#/d' | tr '\n' ' ')
    debootstrap --arch=amd64 --components=main,contrib,non-free --include=makedev,locales --no-check-gpg --keep-debootstrap-dir stretch "${TARGETPATH}"

    # Copy any packages downloaded by debootstrap back into our shared cache.
    function cache_downloaded_packages () {
        rsync --archive --filter "include **/*.deb" --filter "exclude *" "${TARGETPATH}/var/cache/apt/archives" src/DEBCACHE/
    }
    cache_downloaded_packages


    function ensure_directory_exists () {
        if [[ "$1" != "" ]]; then
            dpath=$(dirname "$1")
            mkdir -p "$dpath"
        fi
    }

    # Create a naive set of device files inside the chroot. We have to do this
    # before we bind the host /dev/pts to the /dev/pts path inside the chroot.
    chroot "${TARGETPATH}" /sbin/MAKEDEV generic

    # We're going to use chroot to run apt-get inside the target filesystem.
    # The post-install scripts of some packages will require the proc and device
    # filesystems.
    OUTSIDE_PROCPATH="${TARGETPATH}/proc"
    OUTSIDE_DEVPTSPATH="${TARGETPATH}/dev/pts"
    mount --bind /dev/pts "${OUTSIDE_DEVPTSPATH}"
    mount -t proc proc "${OUTSIDE_PROCPATH}"


    # Create a script inside the target directory so that it can be run from within a chroot
    INSIDE_SCRIPTPATH="/tmp/setup-inside-chroot.sh"
    OUTSIDE_SCRIPTPATH="${TARGETPATH}${INSIDE_SCRIPTPATH}"
    ensure_directory_exists "${OUTSIDE_SCRIPTPATH}"
    cat > "${OUTSIDE_SCRIPTPATH}" <<-EOF
        locale-gen

	groupadd --system autologin
	groupadd --system nopasswdlogin
	useradd --user-group --groups autologin,nopasswdlogin,netdev cctv 
	echo cctv:cctv | chpasswd


        export DEBIAN_PRIORITY=critical
        export DEBIAN_FRONTEND=noninteractive
        apt-get clean
        apt-get update
        apt-get -o Dpkg::Options::="--force-confdef" -o Dpkg::Options::="--force-confnew" --assume-yes --show-progress install ${APT_PKGLIST}
EOF
    chmod u+x "${OUTSIDE_SCRIPTPATH}"
    OUTSIDE_DEVPTSPATH="${TARGETPATH}/dev/pts"
    mount --bind /dev/pts "${OUTSIDE_DEVPTSPATH}"
    chroot "${TARGETPATH}" "${INSIDE_SCRIPTPATH}"

    cache_downloaded_packages

    # Copy our config files into the chroot
    rsync --verbose --recursive --links --times src/post-bootstrap/ "${TARGETPATH}/"    
EOF


fi # End of [[ "${1}" == "build" ]]

